<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js V8 Engine Demo</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color: #111;
      color: #eee;
    }

    #container {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px 12px;
      background: rgba(0, 0, 0, 0.65);
      border-radius: 8px;
      font-size: 13px;
      line-height: 1.4;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    #ui label {
      display: block;
      margin-bottom: 4px;
      font-weight: 600;
    }

    #ui input[type="range"] {
      width: 200px;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <div id="ui">
    <label for="rpmSlider">
      Engine Speed:
      <span id="rpmValue">1500</span> rpm
    </label>
    <input id="rpmSlider" type="range" min="200" max="6000" step="100" value="1500">
  </div>

  <!-- Three.js core -->
  <script src="https://unpkg.com/three@0.165.0/build/three.min.js"></script>
  <!-- OrbitControls -->
  <script src="https://unpkg.com/three@0.165.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    (function () {
      const container = document.getElementById('container');

      // Scene & renderer
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(14, 10, 18);
      camera.lookAt(0, 3, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      container.appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.target.set(0, 3, 0);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight1.position.set(10, 20, 10);
      scene.add(dirLight1);

      const dirLight2 = new THREE.DirectionalLight(0x88aaff, 0.5);
      dirLight2.position.set(-10, 15, -8);
      scene.add(dirLight2);

      // Ground grid
      const grid = new THREE.GridHelper(80, 40, 0x444444, 0x222222);
      grid.position.y = 0;
      scene.add(grid);

      // Engine block
      const blockGeo = new THREE.BoxGeometry(10, 3, 10);
      const blockMat = new THREE.MeshStandardMaterial({
        color: 0x222222,
        metalness: 0.3,
        roughness: 0.7
      });
      const block = new THREE.Mesh(blockGeo, blockMat);
      block.position.y = 2;
      scene.add(block);

      // Engine group (cylinders + pistons)
      const engineGroup = new THREE.Group();
      engineGroup.position.y = 3; // above block
      scene.add(engineGroup);

      // Crankshaft
      const crankGeo = new THREE.CylinderGeometry(0.4, 0.4, 9, 24);
      const crankMat = new THREE.MeshStandardMaterial({
        color: 0x999999,
        metalness: 0.9,
        roughness: 0.25
      });
      const crankshaft = new THREE.Mesh(crankGeo, crankMat);
      crankshaft.position.y = engineGroup.position.y - 1.0; // slightly below cylinders
      scene.add(crankshaft); // separate from engineGroup, rotates around its own Y

      // Pistons & cylinders
      const pistonData = [];

      const cylinderGeo = new THREE.CylinderGeometry(0.9, 0.9, 4, 24, 1, true);
      const cylinderCapGeo = new THREE.CircleGeometry(0.9, 24);
      const pistonGeo = new THREE.CylinderGeometry(0.7, 0.7, 1.0, 24);

      const stroke = 1.0;                  // piston stroke amplitude
      const cylinderSpacing = 2.4;         // distance between cylinders in same bank
      const bankOffsetX = 3.0;             // distance of bank from center along X
      const bankAngleDeg = 35;             // V angle (each bank from vertical)
      const bankAngleRad = THREE.MathUtils.degToRad(bankAngleDeg);

      let pistonIndex = 0; // used to spread phases across 8 pistons

      function createBank(isLeft) {
        const bankGroup = new THREE.Group();
        bankGroup.position.x = isLeft ? -bankOffsetX : bankOffsetX;
        bankGroup.rotation.z = isLeft ? bankAngleRad : -bankAngleRad;

        const cylinderColor = isLeft ? 0x3b82f6 : 0xf97316;

        const cylinderMat = new THREE.MeshStandardMaterial({
          color: cylinderColor,
          metalness: 0.3,
          roughness: 0.4,
          transparent: true,
          opacity: 0.65,
          side: THREE.DoubleSide
        });

        const capMat = new THREE.MeshStandardMaterial({
          color: cylinderColor,
          metalness: 0.5,
          roughness: 0.2
        });

        const pistonMat = new THREE.MeshStandardMaterial({
          color: 0xd4d4d8,
          metalness: 0.8,
          roughness: 0.3
        });

        for (let i = 0; i < 4; i++) {
          const pairGroup = new THREE.Group();
          const zPos = (i - 1.5) * cylinderSpacing; // center the 4 cylinders
          pairGroup.position.z = zPos;

          // Cylinder barrel
          const cylinder = new THREE.Mesh(cylinderGeo, cylinderMat);
          cylinder.position.y = 2.0; // half of 4

          // Cylinder top cap (head)
          const cap = new THREE.Mesh(cylinderCapGeo, capMat);
          cap.rotation.x = -Math.PI / 2;
          cap.position.y = 4.0;

          // Piston
          const piston = new THREE.Mesh(pistonGeo, pistonMat);
          const baseY = 1.3; // within cylinder interior
          piston.position.y = baseY;

          // Decorative piston head ring
          const headGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.2, 24);
          const head = new THREE.Mesh(headGeo, capMat);
          head.position.y = baseY + 0.5;
          piston.add(head);

          pairGroup.add(cylinder);
          pairGroup.add(cap);
          pairGroup.add(piston);

          bankGroup.add(pairGroup);

          // Phase offset per piston (simplified firing order visualisation)
          const phase = pistonIndex * (Math.PI / 4); // 8 pistons over 2Ï€

          pistonData.push({
            mesh: piston,
            baseY: baseY,
            stroke: stroke,
            phase: phase
          });

          pistonIndex++;
        }

        engineGroup.add(bankGroup);
      }

      // Create left and right banks (V8)
      createBank(true);  // left bank
      createBank(false); // right bank

      // UI elements
      const rpmSlider = document.getElementById('rpmSlider');
      const rpmValue = document.getElementById('rpmValue');

      let rpm = parseFloat(rpmSlider.value);
      rpmValue.textContent = rpm.toString();

      rpmSlider.addEventListener('input', function () {
        rpm = parseFloat(this.value);
        rpmValue.textContent = rpm.toString();
      });

      // Animation state
      let crankAngle = 0;
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();

        // Convert rpm to angular speed (rad/s)
        const angularSpeed = rpm * 2 * Math.PI / 60;
        crankAngle += angularSpeed * delta;

        // Keep angle bounded
        if (crankAngle > Math.PI * 2) {
          crankAngle -= Math.PI * 2;
        }

        // Rotate crankshaft
        crankshaft.rotation.y = crankAngle;

        // Animate pistons: simple sinusoidal motion tied to crankAngle + phase
        for (let i = 0; i < pistonData.length; i++) {
          const p = pistonData[i];
          const offset = Math.sin(crankAngle + p.phase) * p.stroke * 0.5;
          p.mesh.position.y = p.baseY + offset;
        }

        controls.update();
        renderer.render(scene, camera);
      }

      animate();

      // Resize handling
      window.addEventListener('resize', onWindowResize, false);

      function onWindowResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
      }
    })();
  </script>
</body>
</html>
